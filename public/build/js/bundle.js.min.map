{"version":3,"sources":["horas.js","ponentes.js","tags.js"],"names":["document","querySelector","categoria","dias","querySelectorAll","inputHiddenDia","inputHiddenHora","addEventListener","terminoBusqueda","forEach","dia","busqueda","categoria_id","value","e","target","name","horaPrevia","classList","remove","Object","values","includes","buscarEventos","async","url","resultado","fetch","eventos","listadoHoras","li","add","horasTomadas","map","evento","hora_id","listadoHorasArray","Array","from","filter","dataset","horaId","hora","seleccionarHora","obtenerHorasDisponibles","json","id","horaSeleccionada","onclick","ponentesInput","ponentes","ponentesFiltrados","listadoPonentes","ponenteHidden","seleccionarPonente","ponente","ponentePrevio","ponenteId","respuesta","arrayPonentes","nombre","trim","apellido","formatearPonentes","obtenerPonentes","length","expresion","RegExp","toLowerCase","search","firstChild","removeChild","ponenteHTML","createElement","textContent","appendChild","noResultados","append","mostrarPonentes","tagsInput","tagsDiv","tagsInputHidden","tags","mostrarTags","tag","etiqueta","ondblclick","elimininarTag","actualizarInputHidden","toString","split","keyCode","preventDefault"],"mappings":"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","file":"bundle.js","sourcesContent":["(function() {\r\n    const horas = document.querySelector(\"#horas\")\r\n\r\n    if(horas) {\r\n        \r\n        const categoria = document.querySelector('[name=\"categoria_id\"]')   //select del tipo de evento\r\n        const dias = document.querySelectorAll('[name=\"dia\"]')  //inputs radio\r\n        const inputHiddenDia = document.querySelector('[name=\"dia_id\"]')\r\n        const inputHiddenHora = document.querySelector('[name=\"hora_id\"]')\r\n\r\n        //cuando se detecte cambios en el select de categoria o en el input de dia, envio sus values al objeto\r\n        categoria.addEventListener(\"change\", terminoBusqueda)\r\n        dias.forEach(dia => dia.addEventListener(\"change\", terminoBusqueda))\r\n\r\n        let busqueda = {\r\n            categoria_id: +categoria.value ?? \"\",    //guardo el value del select de la categorias traidas de la bd si estoy en el formulario de editar. Si es el form de crear, inicia vacio. Le pongo el + adelante para convertir el valor de string a integer\r\n            dia: +inputHiddenDia.value ?? \"\"    //guardo el value que traigo del dia_id guardado en el evento en la bd si estoy en el formulario de editar. Si es el form de crear, inicia vacio. Le pongo el + adelante para convertir el valor de string a integer\r\n        }\r\n\r\n        //Si el busqueda ya contiene los datos de la bd, busco el evento directamente. Sino, tengo que esperar que haya un eventlistener para que se llene el objeto busqueda\r\n        if(!Object.values(busqueda).includes(\"\")) {\r\n            //Creo esta funcio IIFE que se llama automaticamente\r\n            (async () => {\r\n                //Busco el evento segun lo que tenga en el objeto busqueda\r\n                await buscarEventos()\r\n\r\n                //Guardo el id del input oculto, que se llena manualmente clikeando la hora o trayendo la hora de la bd. \r\n                const id = inputHiddenHora.value\r\n\r\n                //Selecciono el li que contenga el mismo valor que el input oculto en su atributo\r\n                const horaSeleccionada = document.querySelector(`[data-hora-id=\"${id}\"]`)\r\n\r\n                //Le quito la calse deshabilitada\r\n                horaSeleccionada.classList.remove(\"horas__hora--deshabilitada\")\r\n\r\n                //Le añado la clase seleccionada para identificar que ésta es la hora que se seleccionó y guardó en la bd del evento a editar\r\n                horaSeleccionada.classList.add(\"horas__hora--seleccionada\")\r\n\r\n                //si le hago click a otra hora, y luego a esta seleccionada, elimino las clases y valores que se le asignaron al li e imput de la otra hora y se los asigno a esta\r\n                horaSeleccionada.onclick = seleccionarHora\r\n            }) ();\r\n        }\r\n\r\n\r\n        function terminoBusqueda(e) {\r\n            //Guardo el value del elemento html en el objeto\r\n            busqueda[e.target.name] = e.target.value\r\n\r\n            //Reiniciar los campos ocultos\r\n            inputHiddenHora.value = \"\"\r\n            inputHiddenDia.value = \"\"\r\n\r\n            //Deshabilitar estilos de la hora seleccionada anteriormente si hay un nuevo click en dias o categoria\r\n            const horaPrevia = document.querySelector(\".horas__hora--seleccionada\")\r\n            if(horaPrevia) {\r\n                horaPrevia.classList.remove(\"horas__hora--seleccionada\")\r\n            }\r\n            \r\n            if(Object.values(busqueda).includes(\"\")) {\r\n                return\r\n            }\r\n            buscarEventos()\r\n        }\r\n        \r\n        //si el objeto de busqueda tiene las 2 keys con valor\r\n        async function buscarEventos() {\r\n            const {categoria_id, dia} = busqueda\r\n            \r\n            const url = `/api/eventos-horario?dia_id=${dia}&categoria_id=${categoria_id}`\r\n            const resultado = await fetch(url)  //le hago un get a la url\r\n            const eventos = await resultado.json()  //consumo los datos provenientes del echo del APIEventos.php\r\n            \r\n            obtenerHorasDisponibles(eventos)\r\n        }\r\n\r\n        function obtenerHorasDisponibles(eventos) {\r\n            //Selecciono todos los li de horas\r\n            const listadoHoras = document.querySelectorAll(\"#horas li\")\r\n\r\n            //Le añado la clase a todos los li\r\n            listadoHoras.forEach(li => li.classList.add(\"horas__hora--deshabilitada\"))            \r\n\r\n            //Recorro los eventos y guardo las id de sus horas\r\n            const horasTomadas = eventos.map(evento => evento.hora_id)\r\n\r\n            //Convierto el listadoHoras que es un NodeList a un array\r\n            const listadoHorasArray = Array.from(listadoHoras)  \r\n\r\n            //Filtro todas las horas que no existan en horasTomadas\r\n            const resultado = listadoHorasArray.filter(li => !horasTomadas.includes(li.dataset.horaId)) //dataset hace referencia a el atributo personalizado llamado \"data-hora-id\" en el li del formulario\r\n            \r\n            //A cada hora disponible le saco la clase --deshabilitada por default para que se vean como disponibles gracias a css\r\n            resultado.forEach(li => li.classList.remove(\"horas__hora--deshabilitada\"))\r\n\r\n            //selecciono todos los li de horas que no tengan la clase --deshabilitada para que solo esos li puedan reaccionar a un event\r\n            const horasDisponibles = document.querySelectorAll(\"#horas li:not(.horas__hora--deshabilitada)\") \r\n\r\n            horasDisponibles.forEach(hora => hora.addEventListener(\"click\", seleccionarHora))\r\n        }\r\n\r\n        function seleccionarHora(e) {\r\n            //Deshabilitar la hora seleccionada anteriormente si hay un nuevo click\r\n            const horaPrevia = document.querySelector(\".horas__hora--seleccionada\")\r\n            if(horaPrevia) {\r\n                horaPrevia.classList.remove(\"horas__hora--seleccionada\")\r\n            }\r\n\r\n            //Agregar clase a la hora seleccionada\r\n            e.target.classList.add(\"horas__hora--seleccionada\") //agrego la clase al li que clickee\r\n\r\n            //Agregar id de la hora al campo oculto\r\n            inputHiddenHora.value = e.target.dataset.horaId //dataset hace referencia a el atributo personalizado llamado \"data-hora-id\" en el li del formulario\r\n\r\n            //Agregar id del dia al campo oculto\r\n            inputHiddenDia.value = document.querySelector('[name=\"dia\"]:checked').value //selecciono el elemento con name=dia pero que sea el que está clickeado\r\n        }\r\n    }\r\n}) ();","(function () {\r\n    const ponentesInput = document.querySelector(\"#ponentes\")\r\n\r\n    if(ponentesInput) {\r\n        let ponentes = []\r\n        let ponentesFiltrados = []\r\n\r\n        //selecciono el ul\r\n        const listadoPonentes = document.querySelector(\"#listado-ponentes\")\r\n        const ponenteHidden = document.querySelector('[name=\"ponente_id\"]')\r\n        obtenerPonentes()\r\n\r\n        //Cuando se escriba en el input\r\n        ponentesInput.addEventListener(\"input\", buscarPonentes)\r\n\r\n        async function obtenerPonentes() {\r\n            \r\n            const url = `/api/ponentes`\r\n            const respuesta = await fetch(url) \r\n            const resultado = await respuesta.json()\r\n            \r\n            formatearPonentes(resultado)\r\n        }\r\n\r\n        function formatearPonentes(arrayPonentes = []) {    //inicio el array vacio si no existe resultado\r\n            ponentes = arrayPonentes.map(ponente => {\r\n                return {    //en el array de ponentes solo coloco los datos que necesito\r\n                    id: ponente.id,\r\n                    nombre: `${ponente.nombre.trim()} ${ponente.apellido.trim()}`\r\n                }\r\n            })\r\n        }\r\n\r\n        function buscarPonentes(e) {\r\n            //guardo lo que escribo\r\n            const busqueda = e.target.value\r\n\r\n            //reseteo el input hidden\r\n            ponenteHidden.value = \"\"\r\n            \r\n            //si ya ingresé mas de 3 letras en el input\r\n            if(busqueda.length > 3) {   \r\n                const expresion = new RegExp(busqueda, \"i\") //creo una nueva expresion regular, con \"i\" le digo que no importa si escribo con mayus o min\r\n                ponentesFiltrados = ponentes.filter(ponente => {\r\n                    if(ponente.nombre.toLowerCase().search(expresion) !== -1) { //.search() devuelve -1 si no se encuentran coincidencias, sino devuelve 0. Se usa .search() porque se usa RegExp\r\n                        return ponente; //guardo el objeto entero en el el array de filtrados\r\n                    }\r\n                })\r\n            } else {\r\n                ponentesFiltrados = []\r\n            }\r\n            mostrarPonentes()\r\n        }\r\n        \r\n        function mostrarPonentes() {\r\n            //si hay elementos li dentro del ul los elimino, para evitar duplicados por cada letra ingresada\r\n            while(listadoPonentes.firstChild) {\r\n                listadoPonentes.removeChild(listadoPonentes.firstChild)\r\n            }\r\n\r\n            if(ponentesFiltrados.length > 0) {\r\n                ponentesFiltrados.forEach(ponente => {\r\n                    //Creo la lista\r\n                    const ponenteHTML = document.createElement(\"LI\")\r\n    \r\n                    //Añado la clase\r\n                    ponenteHTML.classList.add(\"listado-ponentes__ponente\")\r\n                    \r\n                    //Le coloco el nombre para que sea visible\r\n                    ponenteHTML.textContent = ponente.nombre\r\n    \r\n                    //Le añado el atributo personalizado data-ponente-id\r\n                    ponenteHTML.dataset.ponenteId = ponente.id\r\n\r\n                    //cuando haga click\r\n                    ponenteHTML.onclick = seleccionarPonente\r\n\r\n                    //Añadir al DOM\r\n                    listadoPonentes.appendChild(ponenteHTML)\r\n                })\r\n            } else {\r\n                const noResultados = document.createElement(\"P\")\r\n                noResultados.classList.add(\"listado-ponentes__no-resultado\")\r\n                noResultados.textContent = \"No hay resultados\"\r\n                listadoPonentes.append(noResultados)\r\n            }\r\n\r\n        }\r\n\r\n        function seleccionarPonente(e) {\r\n            //Obtengo el li al que le hice click\r\n            const ponente = e.target\r\n\r\n            //remover clase al li en caso de que lo haya seleccionado previamente\r\n            const ponentePrevio = document.querySelector(\".listado-ponentes__ponente--seleccionado\")\r\n            if(ponentePrevio) {\r\n                ponentePrevio.classList.remove(\"listado-ponentes__ponente--seleccionado\")\r\n            }\r\n            \r\n            //agrego clase\r\n            ponente.classList.add(\"listado-ponentes__ponente--seleccionado\")\r\n\r\n            //Agrego el valor del atributo personalizado del li que seleccioné\r\n            ponenteHidden.value = ponente.dataset.ponenteId\r\n        }\r\n    }\r\n}) ();","(function () {  //esta funcion encerrada en parentesis se llama iife. Esta funcion se ejecuta solo si la pagina donde estoy hay un input con ese id, en las demas paginas no se ejecuta\r\n    const tagsInput = document.querySelector(\"#tags_input\")\r\n    if(tagsInput) {\r\n        const tagsDiv = document.querySelector(\"#tags\")\r\n        const tagsInputHidden = document.querySelector(\"[name='tags']\")\r\n        let tags = []\r\n\r\n        //Recuperar del input oculto\r\n        if(tagsInputHidden.value !== \"\") {\r\n            tags = tagsInputHidden.value.split(\",\") //el value del input oculto que viene de la bd en forma de string lo convierto a array\r\n            mostrarTags()\r\n        }\r\n\r\n        //Escuchar los cambios en el input. keypress es escuchar al ingreso de letras\r\n        tagsInput.addEventListener(\"keypress\", guardarTag)\r\n\r\n        function guardarTag(e) {\r\n            if(e.keyCode === 44) {  //detecta el ingreso de una ,\r\n                if(e.target.value.trim() === \"\" || e.target.value <1) return    //si se ingresaron solo espacios, no agrega nada al array\r\n                e.preventDefault()  //cuando presione una coma, no la agrega al formulario. Con esto elimino la , luego de ingresarla en el input\r\n                tags = [...tags, e.target.value.trim()] //guardo en el array cada palabra\r\n                tagsInput.value = \"\"    //vacío el input luego de ingresar la palabra\r\n                mostrarTags()\r\n            }\r\n        }\r\n\r\n        function mostrarTags() {\r\n            tagsDiv.textContent = \"\";\r\n            tags.forEach(tag => {\r\n                const etiqueta = document.createElement(\"LI\")   //creo un <li> por cada elemento en el array\r\n                etiqueta.classList.add(\"formulario__tag\")\r\n                etiqueta.textContent = tag  //le agrego el elemento al li\r\n                etiqueta.ondblclick = elimininarTag //cuando haga doble click\r\n                tagsDiv.appendChild(etiqueta)   //le agrego todas las li al div\r\n            })\r\n            \r\n            actualizarInputHidden()\r\n        }\r\n\r\n        function elimininarTag(e) {\r\n            e.target.remove()   //elimino el li\r\n            tags = tags.filter(tag => tag !== e.target.textContent) //elimino el tag del arreglo filtrando los que sean distintos del contenido del li\r\n            actualizarInputHidden()\r\n        }\r\n\r\n        function actualizarInputHidden() {\r\n            tagsInputHidden.value = tags.toString() //coloco todos lo que haya en el array de tags en el value del input oculto\r\n        }\r\n    }\r\n}) ();"]}