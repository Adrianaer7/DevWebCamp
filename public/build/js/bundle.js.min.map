{"version":3,"sources":["tags.js"],"names":["tagsInput","document","querySelector","tagsDiv","tagsInputHidden","tags","mostrarTags","textContent","forEach","tag","etiqueta","createElement","classList","add","ondblclick","elimininarTag","appendChild","actualizarInputHidden","e","target","remove","filter","value","toString","split","addEventListener","keyCode","trim","preventDefault"],"mappings":"CAAA,WACA,MAAAA,EAAAC,SAAAC,cAAA,eACA,GAAAF,EAAA,CACA,MAAAG,EAAAF,SAAAC,cAAA,SACAE,EAAAH,SAAAC,cAAA,iBACA,IAAAG,EAAA,GAqBA,SAAAC,IACAH,EAAAI,YAAA,GACAF,EAAAG,QAAAC,IACA,MAAAC,EAAAT,SAAAU,cAAA,MACAD,EAAAE,UAAAC,IAAA,mBACAH,EAAAH,YAAAE,EACAC,EAAAI,WAAAC,EACAZ,EAAAa,YAAAN,KAGAO,IAGA,SAAAF,EAAAG,GACAA,EAAAC,OAAAC,SACAf,EAAAA,EAAAgB,OAAAZ,GAAAA,IAAAS,EAAAC,OAAAZ,aACAU,IAGA,SAAAA,IACAb,EAAAkB,MAAAjB,EAAAkB,WAtCA,KAAAnB,EAAAkB,QACAjB,EAAAD,EAAAkB,MAAAE,MAAA,KACAlB,KAIAN,EAAAyB,iBAAA,YAEA,SAAAP,GACA,GAAA,KAAAA,EAAAQ,QAAA,CACA,GAAA,KAAAR,EAAAC,OAAAG,MAAAK,QAAAT,EAAAC,OAAAG,MAAA,EAAA,OACAJ,EAAAU,iBACAvB,EAAA,IAAAA,EAAAa,EAAAC,OAAAG,MAAAK,QACA3B,EAAAsB,MAAA,GACAhB,SAtBA","file":"bundle.js","sourcesContent":["(function () {  //esta funcion encerrada en parentesis se llama iife. Esta funcion se ejecuta solo si la pagina donde estoy hay un input con ese id, en las demas paginas no se ejecuta\r\n    const tagsInput = document.querySelector(\"#tags_input\")\r\n    if(tagsInput) {\r\n        const tagsDiv = document.querySelector(\"#tags\")\r\n        const tagsInputHidden = document.querySelector(\"[name='tags']\")\r\n        let tags = []\r\n\r\n        //Recuperar del input oculto\r\n        if(tagsInputHidden.value !== \"\") {\r\n            tags = tagsInputHidden.value.split(\",\") //el value del input oculto que viene de la bd en forma de string lo convierto a array\r\n            mostrarTags()\r\n        }\r\n\r\n        //Escuchar los cambios en el input. keypress es escuchar al ingreso de letras\r\n        tagsInput.addEventListener(\"keypress\", guardarTag)\r\n\r\n        function guardarTag(e) {\r\n            if(e.keyCode === 44) {  //detecta el ingreso de una ,\r\n                if(e.target.value.trim() === \"\" || e.target.value <1) return    //si se ingresaron solo espacios, no agrega nada al array\r\n                e.preventDefault()  //cuando presione una coma, no la agrega al formulario. Con esto elimino la , luego de ingresarla en el input\r\n                tags = [...tags, e.target.value.trim()] //guardo en el array cada palabra\r\n                tagsInput.value = \"\"    //vacÃ­o el input luego de ingresar la palabra\r\n                mostrarTags()\r\n            }\r\n        }\r\n\r\n        function mostrarTags() {\r\n            tagsDiv.textContent = \"\";\r\n            tags.forEach(tag => {\r\n                const etiqueta = document.createElement(\"LI\")   //creo un <li> por cada elemento en el array\r\n                etiqueta.classList.add(\"formulario__tag\")\r\n                etiqueta.textContent = tag  //le agrego el elemento al li\r\n                etiqueta.ondblclick = elimininarTag //cuando haga doble click\r\n                tagsDiv.appendChild(etiqueta)   //le agrego todas las li al div\r\n            })\r\n            \r\n            actualizarInputHidden()\r\n        }\r\n\r\n        function elimininarTag(e) {\r\n            e.target.remove()   //elimino el li\r\n            tags = tags.filter(tag => tag !== e.target.textContent) //elimino el tag del arreglo filtrando los que sean distintos del contenido del li\r\n            actualizarInputHidden()\r\n        }\r\n\r\n        function actualizarInputHidden() {\r\n            tagsInputHidden.value = tags.toString() //coloco todos lo que haya en el array de tags en el value del input oculto\r\n        }\r\n    }\r\n}) ()"]}